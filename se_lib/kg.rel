// *****************************************************************
// Sales Engineering Visualizations
//
// Tools for creating knowledge graphs and visualizations.
//
// INSTALL this source: kg.rel
// *****************************************************************

module se_kg

    // make knowledge graph (KG)
    // This function expects data model DATA and config META
    // to create corresponding KG
    @outline
    def make_knowledge_graph[DATA, META](entity_name in RelName, e in Entity) = 
            DATA(entity_rel, entity_attr, e, _) and
            META(entity_rel, :entity_name, entity_name)
            from entity_attr in RelName, entity_rel
    @outline
    def make_knowledge_graph[DATA, META](r in RelName, e1 in Entity, e2 in Entity) = 
            DATA(entity_rel, r, e1, e2, xs...) 
            from entity_rel in RelName, xs...

    @inline
    module get_kg_signature[KG]
        def _nodes = count[r in RelName, e in Entity: imdb_kg_ext(r, e)]
        def _edges = count[r in RelName, e1 in Entity, e2 in Entity: imdb_kg_ext(r, e1, e2, xs...) and r!=:show from xs...]
        def __entity_counts[r in RelName] = count[e: imdb_kg_ext(r, e)]
        def __relation_counts[r in RelName] = count[e1, e2: imdb_kg_ext(r, e1, e2, xs...) and r!=:show from xs...]
        def ___shows = count[xs...: imdb_kg_ext(:show, xs...)]
    end

    // graph signature to compare graph topologies -
    // use equal[graph1, graph2] for exact match
    // @outline
    // module get_kg_signature[KG] 
    //     def node_count = 
    //     def edge_count = 
    //     def avg_degree = 
    //     def node_degrees = 
    //     def entities = KG
    // end

    // distill ontology 
    // This function expects 2 parameters
    // KG - knowledge graph defined as a module consisting of two types of relations: 
    //   1. entities: defined as 2-arity tuples (EntityName: relName, Hash: Entity)
    //   2. relationships: defined as 3+ arity tuples (RelationshipName: relName, Hash: Entity, Hash: Entity, optional attributes)
    // Then distill_kg_ontology builds an ontology based on entities and relationships above.
    // Example of KG module:
    //
    // module my_knowledge_graph
    //      def Company(e) = company:name(e, _)
    //      def Site(e) = site:id(e, _)
    //      def Workorder(e) = workorder:id(e, _)
    //
    //      def created_for(w, c) = workorder:company(w, c)
    //      def serviced_at(w, s) = workorder:site(w, s)
    // end
    @outline
    module distill_kg_ontology[KG, OPTS]
        def node = string[v] from v where KG(v, _)
        def edge = v1str, v2str: v1str=string[v1] and v2str=string[v2] and
                                KG(_, x, y) and KG(v1, x) and KG(v2, y) and
                                Entity(x) and Entity(y)
                                from x, y, v1, v2
        def edge_attribute = v1str, v2str, "label", estr: 
                                estr=string[e] and
                                v1str=string[v1] and v2str=string[v2] and
                                KG(e, x, y) and
                                KG(v1, x) and 
                                KG(v2, y)
                                from x, y, e, v1, v2

        def layout = OPTS:graphviz:layout <++ "dot" 
        def attribute:graph["rankdir"] = if layout="dot" then (OPTS:graphviz:direction <++ "LR") else {} end
        def node_attribute[vs, "shape"] = shape_map[KG, OPTS][v], vs=string[v] from v where KG(v, _)
        def attribute[:graph, "label"] = "%(OPTS:graphviz:title <++ "Knowledge Graph") Ontology"
        def attribute[:graph, "labelloc"] = "t"
    end


    // Make ego-graph of KG
    // Ego graph begins with seed nodes (entities) plus all nodes that are up to max_distance
    // distance from them.
    // Parameters:
    // KG - a knowledge graph to operate on
    // seeds - seed entity nodes
    // max_distance - maximum distanced nodes from seeds to include in result
    @outline // @ondemand
    def _make_ego_kg[KG, seeds in Entity, max_distance in range[0, 10, 1]]
            (ename in RelName, e in Entity, 0) = 
                                    KG(ename, e) and e=seeds
    // recursively add nodes - degree + 1 
    @outline // @ondemand
    def _make_ego_kg[KG, seeds in Entity, max_distance in range[0, 10, 1]]
            (ename in RelName, e in Entity, deg in Int) = 
                                    KG(ename, e) and 
                                    (KG(rlshp, le, e) or KG(rlshp, e, le)) and 
                                    _make_ego_kg[KG, seeds, max_distance](_, le, pdeg) and 
                                    deg=pdeg+1 
                                    from le in Entity, pdeg in Int, rlshp in RelName
                                    where pdeg < max_distance
    // add relations
    @outline // @ondemand
    def _make_ego_kg[KG, seeds in Entity, max_distance in range[0, 10, 1]]
            (rel in RelName, e1 in Entity, e2 in Entity) = 
                                    KG(rel, e1, e2) and 
                                    _make_ego_kg[KG, seeds, max_distance](_, e1, i) and 
                                    _make_ego_kg[KG, seeds, max_distance](_, e2, j)
                                    from i in range[0, 10, 1], j in range[0, 10, 1]

    // copy KG and remove distances 
    @inline
    def remove_distance[KG_with_distance](ename in RelName, e in Entity) = KG_with_distance(ename, e, deg) from deg in Int
    @inline
    def remove_distance[KG_with_distance](rel in RelName, e1 in Entity, e2 in Entity) = KG_with_distance(rel, e1, e2)


    // Make ego-graph of KG
    @inline
    def make_ego_kg[KG, seeds in Entity, max_distance in range[0, 10, 1]] = 
                                    remove_distance[_make_ego_kg[KG, seeds, max_distance]]

    
    // Prepare Knowledge Graph for graphviz
    @outline
    module make_graphviz_object[KG, OPTS]
        def node(e in Entity) = KG(r, e) from r in RelName
        def edge(n1 in Entity, n2 in Entity) = KG(r, n1, n2) from r in RelName

        def node_attribute[n, "label"] = OPTS:ui:show[n], node(n)

        // graphviz options
        def node_attribute[n, "shape"] = shape_map[KG, OPTS][t] from t where KG(t, n)

        def edge_attribute = x in Entity, y in Entity, "label", rstr: 
                                rstr=string[r] and
                                KG(r, x, y) and
                                OPTS:graphviz:label_edges(boolean_true)
                                from r in RelName
        
        def layout = OPTS:graphviz:layout <++ "dot" 
        def attribute:graph["rankdir"] = if layout="dot" then (OPTS:graphviz:direction <++ "LR") else {} end
        def attribute[:graph, "label"] = OPTS:graphviz:title <++ "Knowledge Graph"
        def attribute[:graph, "labelloc"] = "t"
    end

    // Auxiliary function to populate complete shape map 
    // based on options
    @inline
    def shape_map[KG, OPTS] =
        default_value[first[se_util:arity_filter[KG, 2]],
                    if se_util:exists_relname[OPTS, :graphviz] and 
                        se_util:exists_relname[OPTS:graphviz, :entity_shape]
                    then OPTS:graphviz:entity_shape 
                    else {} 
                    end, 
                    "box"]
end