// *****************************************************************
// Sales Engineering Visualizations
//
// Tools for creating knowledge graphs and visualizations.
//
// INSTALL this source: kg.rel
// *****************************************************************

module se_kg

    // make knowledge graph (KG)
    // This function expects data model DATA and config META
    // to create corresponding KG
    @outline
    def make_knowledge_graph[DATA, META](entity_name in RelName, e in Entity) = 
            DATA(entity_rel, entity_attr, e, _) and
            META(entity_rel, :entity_name, entity_name)
            from entity_attr in RelName, entity_rel
    @outline
    def make_knowledge_graph[DATA, META](r in RelName, e1 in Entity, e2 in Entity) = 
            DATA(entity_rel, r, e1, e2, xs...) 
            from entity_rel in RelName, xs...


    // Given KG produce graphlib graph object
    @inline
    def make_directed_graph[KG] = 
        directed_graph[{n1 in Entity, n2 in Entity: KG(r, n1, n2) from r in RelName}]

        
    @inline
    def subset_kg[KG, NODE](t, a) =
        KG(t, a) and a=NODE
    @inline
    def subset_kg[KG, NODE](r, a, b) =
        KG(r, a, b) and a=NODE and b=NODE

    // filter KG by types of entities and types of relations
    // KG - knowledge graph to filter
    // TYPES - types of entities to filter by
    // RELATIONS - types of relations to filter by
    @inline
    def filter_kg_by_type[KG, TYPES](t, a) =
            KG(TYPES, a)
    @inline 
    def filter_kg_by_type[KG, TYPES](r, a, b) =
            KG(r, a, b) and KG(TYPES, a) and KG(TYPES, b)
    @inline
    def filter_kg_by_relation[KG, RELATIONS](t, a) {
        KG(t, a) and (KG(RELATIONS, a, _) or KG(RELATIONS, _, a))
    }
    @inline
    def filter_kg_by_relation[KG, RELATIONS](r, a, b) {
        KG(RELATIONS, a, b) and r=RELATIONS 
    }
    @inline
    def filter_kg[KG, TYPES, RELATIONS] =
        if count[TYPES]>0 and count[RELATIONS]>0 
        then filter_kg_by_relation[filter_kg_by_type[KG, TYPES], RELATIONS]
        else if count[TYPES]>0 
             then filter_kg_by_type[KG, TYPES] 
             else if count[RELATIONS]>0 
                  then filter_kg_by_relation[KG, RELATIONS]
                  else KG
                  end 
             end 
        end

    @inline
    module get_kg_signature[KG]
        def total_nodes = count[r in RelName, e in Entity: KG(r, e)]
        def total_edges = count[r in RelName, e1 in Entity, e2 in Entity: KG(r, e1, e2, xs...) and r!=:show from xs...]
        def __entity_counts[r in RelName] = count[e: KG(r, e)]
        def __relation_counts[r in RelName] = count[e1, e2: KG(r, e1, e2, xs...) and r!=:show from xs...]
        def ___shows = count[xs...: KG(:show, xs...)]
    end

    // graph signature to compare graph topologies -
    // use equal[graph1, graph2] for exact match
    // @outline
    // module get_kg_signature[KG] 
    //     def node_count = 
    //     def edge_count = 
    //     def avg_degree = 
    //     def node_degrees = 
    //     def entities = KG
    // end

    // distill ontology 
    // This function expects 2 parameters
    // KG - knowledge graph defined as a module consisting of two types of relations: 
    //   1. entities: defined as 2-arity tuples (EntityName: relName, Hash: Entity)
    //   2. relationships: defined as 3+ arity tuples (RelationshipName: relName, Hash: Entity, Hash: Entity, optional attributes)
    // Then distill_kg_ontology builds an ontology based on entities and relationships above.
    // Example of KG module:
    //
    // module my_knowledge_graph
    //      def Company(e) = company:name(e, _)
    //      def Site(e) = site:id(e, _)
    //      def Workorder(e) = workorder:id(e, _)
    //
    //      def created_for(w, c) = workorder:company(w, c)
    //      def serviced_at(w, s) = workorder:site(w, s)
    // end
    @outline
    module distill_kg_ontology[KG, MODEL, OPTS]
        def node = despecialize[v] from v in RelName where KG(v, _)
        def edge = despecialize[v1], despecialize[v2] 
                        from v1 in RelName, v2 in RelName, x1 in Entity, x2 in Entity
                        where KG(_, x1, x2) and KG(v1, x1) and KG(v2, x2)
        def edge_attribute = despecialize[v1], despecialize[v2], "label", despecialize[r]
                        from v1 in RelName, v2 in RelName, x1 in Entity, x2 in Entity, r in RelName
                        where KG(r, x1, x2) and KG(v1, x1) and KG(v2, x2)

        def layout = OPTS:graphviz:layout <++ "dot" 
        def attribute:graph["rankdir"] = if layout="dot" then (OPTS:graphviz:direction <++ "LR") else {} end
        def node_attribute[vs, "shape"] = shape_map[KG, OPTS][v] from v in RelName 
                                            where KG(v, _) and despecialize(v, vs) 
                                            // node(despecialize[v]) and 
        def attribute[:graph, "label"] = "%(OPTS:graphviz:title <++ "Knowledge Graph") Ontology"
        def attribute[:graph, "labelloc"] = "t"

        def node_attribute[vs, "tooltip"] = concat["%(vs) attributes:\n", string_join[",\n", enumerate[{despecialize[attr] 
                                                   from attr in RelName, entity_type in RelName, entity_name in RelName, e in Entity, val
                                                   where MODEL(entity_type, attr, e, val) and
                                                   KG(entity_name, e) and 
                                                   despecialize(entity_name, vs) and
                                                   not Entity(val) 
                                            }]]]     
    end    


    // Make ego-graph of KG
    // Ego graph begins with center (seed) entities (nodes) and includes all nodes that are up to radius
    // distance from them.
    // Parameters:
    // KG - a knowledge graph to operate on
    // seeds or center - seed entity nodes
    // distance or radius - maximum distance from center to include nodes
    @inline def induce_kg[KG, NODES](symb, n) = KG(symb, n) and NODES(n)
    @inline def induce_kg[KG, NODES](symb, n, m) = KG(symb, n, m) and NODES(n) and NODES(m)
    @inline def node[KG](n) = KG(_, n)
    @inline def edge[KG](n, m) = KG(_, n, m); KG(_, m, n)

    @outline 
    module ego_graph[KG]
        // n is inside a ball of a given center and radius
        @ondemand def ball(center in node[KG], 0, n) = center = n
        @ondemand def ball(center in node[KG], radius in Int, n) = ball(center, radius-1, n) and radius > 0
        @ondemand def ball(center in node[KG], radius in Int, n) = {
            ball(center, radius-1, m) and
            edge[KG](m, n) and
            radius > 0
            from m
        }
        @ondemand def kg[center, radius] = induce_kg[KG, ball[center, radius]]
    end

    @inline
    def make_ego_kg[KG, seeds, distance] = ego_graph[KG][:kg, seeds, distance]


    // Prepare Knowledge Graph for graphviz
    @outline
    module make_graphviz_object[KG, OPTS]
        def node(e in Entity) = KG(r, e) from r in RelName
        def edge(n1 in Entity, n2 in Entity) = KG(r, n1, n2) from r in RelName

        def node_attribute[n, "label"] = OPTS:ui:show[n], node(n)

        // graphviz options
        def node_attribute[n, "shape"] = shape_map[KG, OPTS][t] from t where KG(t, n)

        // highlight nodes
        def node_attribute[n, "color"] = "red", OPTS:ui:node:highlight(n)
        def node_attribute[n, "fontcolor"] = "white", OPTS:ui:node:highlight(n)
        def node_attribute[n, "style"] = "bold", OPTS:ui:node:highlight(n)
        def node_attribute[n, "style"] = "filled", OPTS:ui:node:highlight(n)

        def edge_attribute = x in Entity, y in Entity, "label", rstr: 
                                rstr=string[r] and
                                KG(r, x, y) and
                                (OPTS:graphviz:label_edges <++ boolean_false)(boolean_true)
                                // in the future consider using multiple dispatch around OPTS:graphviz:label_edges depending
                                // on the type of relation. For example:
                                // OPTS:graphviz:label_edges(r) to label only on specified relationships
                                // and use multiple dispatch approach similar to
                                // https://github.com/RelationalAI/raicode/blob/master/src/rel/vegalite.rel#L625 
                                // but at the level of 
                                // def edge_attribute = ...
                                from r in RelName
        
        def layout = OPTS:graphviz:layout <++ "dot" 
        def attribute:graph["rankdir"] = if layout="dot" then (OPTS:graphviz:direction <++ "LR") else {} end
        def attribute[:graph, "label"] = OPTS:graphviz:title <++ "Knowledge Graph"
        def attribute[:graph, "labelloc"] = OPTS:graphviz:title:location <++ "t"
        def attribute[:graph, "fontsize"] = OPTS:graphviz:title:fontsize <++ 14
    end

    // Auxiliary function to populate complete shape map 
    // based on options
    @inline
    def shape_map[KG, OPTS] =
        default_value[first[se_util:arity_filter[KG, 2]],
                    if se_util:exists_relname[OPTS, :graphviz] and 
                        se_util:exists_relname[OPTS:graphviz, :entity_shape]
                    then OPTS:graphviz:entity_shape 
                    else {} 
                    end, 
                    "box"]
end
